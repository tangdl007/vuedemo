# vuedemo
## vue2 响应式数据的理解？（基本问题，源码是怎么实现的，你用的时候会有什么样的问题）
可以监控数据的获取和修改 针对对象格式会给每个对象的属性进行劫持 方法是Object.defineProperty
> 源码层面 initData -> observer -> defineReactive方法 (内部会对所有的属性进行重写 性能问题) 递归增加对象中的对象增加getter和setter
> 我们在使用Vue的时候 层级过深（考虑优化） 如果数据不是响应式的就不要放在data里面。我们属性取值的时候尽量避免多次取值。如果有些对象是放在data中的但不是响应式的可以考虑用Object.freeze()来冻结对象。
## vue中如何检测数组的变化
vue2中检测数组的变化并没有用object.defineProperty 因为修改索引的情况并不多（如果直接使用object.defineProperty会浪费大量的性能）。采用重写数组的方法来实现（函数劫持）
> initDate -> observer -> 对我们传入的数组进行原型链的修改，后续调用的方法都是重写后的方法 -> 对数组中的每个对象进行代理
修改数组索引和长度无法进行监控
## vue中如何进行依赖收集
-所谓的依赖收集（观察者模式） 被观察者指的是数据(dep)，观察者（watcher 3种渲染watcher、计算属性、用户watcher）
-一个watcher中可能对应这多个数据 watcher还需要保存dep（重新渲染的时候可以让属性重新记录watcher） 计算属性也会用到
> 多对多的关系 一个dep对应多个watcher，一个watcher有多个dep。默认渲染的时候会进行依赖收集（会触发get方法），数据更新了会找到属性对应的watcher进行更新 取值的时候依赖收集 更新的时候视图更新
## 如何理解vue中的模板编译原理
用户传递的是template属性，我们需要将这个template编译成render函数

-template -> ast语法树
-对语法树进行标记(标记的是静态节点)
-将ast语法树生成render函数

> 最终每次渲染的时候可以调用render函数返回对应的虚拟节点   递归是深度优先 先标记儿子再标记自己  递归要创建一个栈 
## vue生命周期的钩子是如何实现的
就是内部利用了一个发布订阅模式，将用户写的钩子维护成一个数组，后续依次调用callHook。 
## vue的生命周期有哪些？一般在哪一步发送请求及原因
- beforeCreate 没有实现响应式数据  组件的父子关系 initLifecycle initEvents $emit $on $once $off  vue3中就没有这个api了
- created 拿到的数据就是响应式 不涉及dom渲染  这个api可以在服务端渲染的时候进行使用 vue3 setup进行取代了
- beforeMount 没有实际价值
- mounted 可以获取dom $el
- beforeUpdate 
- updated 
- actived keep-alive
- deactived
- beforeDestroy  手动调用移除后触发
- destroyed  移除后触发  既不涉及组件 又不涉及watcher  路由切换 v-if切换组件 is 动态组件 手动调用$destroy 实例上的方法都是带$的
- errorCaptured
> 一般最多是在mounted  代码是同步执行的，请求是异步的 生命周期是同步的 请求是异步的 最终获取的数据在mounted之后
## vue.mixin的使用场景和原理
我们可以通过vue.mixin实现逻辑的复用，问题在于数据来源不明确，声明的时候可能会导致命名冲突。vue3中使用composition api解决了复用问题 
> mixin的核心就是合并属性（内部采用了策略模式进行合并）全局mixin，局部mixin。针对不同的属性有不同的合并策略。
## nextTick在哪里使用？原理是？
nextTick内部采用了异步任务进行了包装（多个nextTick调用 内部合并回调）最后在异步任务中批处理
主要应用场景就是异步更新 （默认调度的时候 就会添加一个nextTick任务）用户为了获取最终的渲染结果需要在内部任务执行之后执行。这时候用户需要将对应的逻辑放到nextTick中 只会开启一次异步任务 
## data为什么必须是一个函数？
原因在于针对根实例而言，new Vue。组件是通过同一个构造函数多次创建，如果是同一个对象的话那么数据会被相互影响。我们希望每个组件的的数据源都是独立的，那就每次调用data返回一个新对象
## watcher和computed的区别？
computed和watch的相同点。底层都会创建一个watcher（用法的区别 computed定义的属性可以在模板中使用，watch不能在视图中使用）
- computed 默认不会立即执行 只有取值的时候才会执行 内部会维护一个dirth属性 来控制依赖的值是否发生变化。默认计算属性要同步返回结果
- watch 默认用户会提供一个回调函数，数据变化了就调用这个回调。我们可以监控某个数据的变化，数据变化了执行某些操作
## Vue.set的实现 （delete）
Vue.set 方法是vue中的一个补丁方法。（正常我们添加属性是不会触发更新的，我们数组无法监控到索引和长度） 

如何实现的我们给每一个属性都增添了一个dep属性
> vue3中没有此方法了（当属性添加或者删除时 手动出发对象本身dep来进行更新）
## Vue为什么需要虚拟dom
- 虚拟dom的好处？我们写代码可能要针对不同的平台来使用（weex，web，小程序）可以跨平台，不需要考虑平台问题
- 不用关心兼容性问题，可以在上层将对应的渲染方法传递给我，我来通过虚拟dom渲染即可
- diff算法 针对更新，有了虚拟dom之后我们可以通过diff算法来找到最后的差异进行修改真实dom 减少操作真实dom

> 跨平台、diff算法
## Vue中的diff算法原理
diff算法的特点就是平级比较，内部采用了双指针的方式进行了优化，优化了常见的操作。采用了递归比较的方式。

### 针对一个节点的diff算法
- 先拿出根节点来进行比较如果是同一节点则比较属性，如果不是同一节点直接换成最新的即可。
- 同一节比较属性后，复用老节点。

### 比较儿子
- 一方有儿子 一方没儿子 （添加、删除）
- 两方都有儿子 
    - 优化比较 头头  尾尾  交叉
    - 就做一个映射表，用新的去映射表中查找元素是否存在，存在则移动不存在则插入，最后删除多余的
    - 这里会有多余的移动

> o(n)复杂度的递归比较
## 既然vue通过数据劫持可以精准探测数据变化，为什么还需要虚拟dom进行diff检测差异
- 如果给每个属性都去增加watcher，而且粒度太小也不太好控制，降低watcher的数量（每一个组件都有一个watcher）可以通过diff算法处理渲染过程。通过diff算法和响应式原理折中处理一下。
## 请说明vue中key的作用和原理，谈谈你对它的理解
isSameVnode中会根据key来判断两个元素是否是同一元素，key不相同说明不是同一元素（key在动态列表中不能使用索引=》bug）
我们使用key 尽量要保证key的唯一性（这样可以优化diff算法）
## 谈谈对vue组件化的理解
组件的优点：组件的复用可以根据数据渲染对应的组件，把组件相关的内容放在一起（方便复用）合理规划组件，可以做到更新的时候是组件级更新
组件三大特性： 属性、时间、插槽
> vue中怎么处理组件 1）Vue.extend 根据用户传入的对象生成一个组件的构造函数。2）根据组件产生对应的虚拟节点。3）初始化组件 将我们的虚拟节点转化为真实节点（init方法） new Sub().$mount();
## vue组件的渲染流程（init）
- 将用户传递的参数放到全局 vm.$options.components
- 创建组件的虚拟节点
- 创建真实节点
- vm.$el插入父元素中
## vue中组件的更新流程（prepatch的作用复用组件的实例，并且可以去更新属性，事件，插槽）
- 组件更新的几种情况。1）data数据更新，依赖收集。2）属性更新  可以给组件传入属性，属性变化触发更新。属性本身就是响应式的，我将响应式的数据传递给儿子，儿子在模板中使用，稍后属性变化后，自动更新。3）插槽变化也要更新。
- 组件更新会触发组件的prepatch方法，会复用组件实例，并且比较组件属性 事件 插槽
- 父组件给子组件传递的属性是响应式的，在模板中使用会做依赖收集 收集自己组件的watcher
- 稍后组件更新了 会重新给props赋值 赋值完成后会触发watcher重新更新
## vue中异步组件原理
vue中异步组件的写法有很多主要用作大的组件可以进行异步加载。就是先渲染一个注释标签，等组件加载完毕，最后在重新渲染 froceRender（图片懒加载） 使用异步组件会配合webpack   异步组件是一个函数
> 原理：异步组件默认不会调用Vue.extend方法 所以Ctor上没有cid属性，没有cid属性就是异步组件。会先渲染一个占位符组件。但是如果有loading会先渲染loading，第一轮结束。如果用户调用resolve，会将结果赋予给factory.resolved，强制重新渲染。重新熏染的时候再次进入到resolveAsyncComponent，会直接拿factory.resolved结果进行渲染。
## 函数式组件的优势及原理
> react中也区分了两种组件 一种是类组件，一种是函数式组件（Sub 就是类组件） （函数组件 没有类就没有this，也没有所谓的状态，没有生命周期，好处就是性能好，不需要创建watcher了）适合只有渲染逻辑的情况  函数式组件就是调用render拿到返回结果来渲染，所以性能高。
## vue组件间传值的方式及之间的区别
- props 父传递数据给儿子  属性的原理就是把解析后的props，验证后就会将属性定义在当前的实例上 vm._props（这个对象上的属性都是通过defineReactive来定义的 都是响应式的）组件在渲染的过程中会在vm上取值 _props属性会被代理到vm上。
- emit 儿子触发组件更新 在创建虚拟节点的时候将所有事件 绑定到了listeners 通过$on绑定事件，通过$emit触发事件（发布订阅模式）
- $parent $children 就是在创造子组件的时候，会将父组件的实例传入。在组件本身初始化的时候会构建组件间的父子关系。通过$parent来获取父组件的实例，通过$children来获取子组件的实例。
- ref 可以获取dom和组件实例（虚拟dom没有处理ref，这里无法拿到实例 也无法获取组件实例）  虚拟dom是不依赖平台代码的。创建dom的时候如何处理ref？会将用户所有的dom操作和属性 都维护到一个cbs属性中（create,update,insert,destroy...）。依次调用cbs中create方法。这里就包含ref相关的操作，会操作ref并且赋值。
- inject provide （将父组件的属性暴露出来） 在后代组件中通过inject注入属性  在父组件中提供数据，在子组件汇总递归查找
- $attrs（所有组件上的属性 不涵盖props） $listeners （组件上所有的事件）   
- Vue.observalble 可以创建一个全局的对象用于通信
- Vuex
## v-if和v-for哪个优先级更高   
> v-for的优先级更高，在编译的时候 会将v-for渲染成_l函数 v-if会变成三元表达式  v-if和v-for不要进行联用 
v-if（控制是否渲染） / v-show（控制样式 visibility：hidden display:none） v-show="true" 放在span上会变成块元素吗？为什么不用 visibility：hidden？（占位 不响应事件） 为什么不用opacity（响应事件 占位）
> v-if在编译的时候 会变成三元表达式 但是v-show会变成一个指令
## v-if,v-model,v-for的实现原理
- v-if会编译成三元表达式
- v-for会编译成_l循环
- v-model 干什么的？ 放在表单元素上可是实现双向绑定，放在组件上就不一样了
    - v-model 放在不同的元素上会编译出不同的结果，针对文本来说会处理文本 （会被编译成 value + input + 指令处理） 中文输入开始 中文输入完毕 compositionStart compositionEnd  
    value 和 input实现双向绑定阻止中文触发 指令作用就是处理中文输入完毕之后 手动触发更新
    - v-model绑定到组件上 这里编译一个model对象 组件会创建虚拟节点的时候会有这样一个对象。会看一下里面是否有自定义的props和event，如果没有则会被解析成input + value的语法糖 
## vue中，sync 修饰符的作用，用法及原理。
    -和v-model，这个api是为了实现状态同步，这个东西在vue3中被移除了
    绑定一个属性和更新时间
## Vue.use是干什么的？原理是什么？
- 这里的use方法，目的是将Vue的构造函数传递给插件中，让所有插件依赖的vue是同一个版本 
- 默认调用插件 或者 插件的install方法
- vue-router和vuex里面package的依赖里面是没有vue。是通过参数传递进去的。
## 组件中写name选项有哪些好处及作用
- 在vue中有name属性的组件可以被递归调用（在写模板语法的时候，我们可以通过name属性递归调用自己）
- 在声明组件的时候 Sub.options.components[name] = Sub  他把自己的构造函数放在name属性上了

- 我们用来标识组件 通过name来找到对应的组件 自己封装跨级通信
- name属性可以用作devtool调试工具 来标明具体的组件


































